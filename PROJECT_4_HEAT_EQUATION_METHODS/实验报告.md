# 项目：热传导方程数值解法比较 - 实验报告

**学生姓名：** [王宏阳] 

**学号：** [20231050108] 

**完成日期：** [6.11]

## 1. 实验目的

本实验旨在通过实现和比较四种不同的数值方法求解一维热传导方程，深入理解偏微分方程数值解法的特点、稳定性和精度问题。

## 2. 理论背景

### 2.1 热传导方程

一维热传导方程的数学形式为：

$$\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}$$

其中：
- $u(x,t)$ 是温度分布函数
- $\alpha$ 是热扩散系数
- 边界条件： $u(0,t) = u(L,t) = 0$
- 初始条件： $u(x,0) = f(x)$

### 2.2 数值方法概述

1. **显式差分法（FTCS）**：前向时间，中心空间差分
2. **隐式差分法（BTCS）**：后向时间，中心空间差分
3. **Crank-Nicolson方法**：时间方向二阶精度的隐式方法
4. **solve_ivp方法**：将PDE转化为ODE系统求解

## 3. 算法实现

### 3.1 显式差分法

**核心思想：** [简述算法思路]

**稳定性条件：** $r = \frac{\alpha \Delta t}{(\Delta x)^2} \leq 0.5$

**关键代码片段：**
```python
def solve_explicit(L, alpha, nx, T_final, dt, plot_times=None):
    """
    使用显式有限差分法（FTCS）求解热传导方程。
    
    参数：
        L (float)：求解域的长度
        alpha (float)：热扩散系数
        nx (int)：空间网格点数量
        T_final (float)：最终模拟时间
        dt (float)：时间步长
        plot_times (list)：需要保存结果的时间点列表
        
    返回：
        dict：包含求解结果的字典，包括时间点、温度分布、计算时间等
    """
    if plot_times is None:
        plot_times = [0, 1, 5, 15, 25]
    
    # 计算空间步长
    dx = L / (nx - 1)
    # 计算稳定性参数（傅里叶数）
    r = alpha * dt / (dx**2)
    # 稳定性检查
    if r > 0.5:
        print(f"警告：显式方法的稳定性条件被违反！r = {r:.4f} > 0.5")
        print(f"建议将时间步长减小到 < {0.5 * dx**2 / alpha:.6f}")
    
    # 获取初始条件
    u, x = set_initial_condition(L, nx)
    t = 0.0
    # 计算总时间步数
    nt = int(T_final / dt) + 1
    
    # 存储结果的字典
    results = {'times': [], 'solutions': [], 'method': '显式有限差分法（FTCS）'}
    
    # 存储初始条件
    if 0 in plot_times:
        results['times'].append(0.0)
        results['solutions'].append(u.copy())
    
    start_time = time.time()  # 开始计时
    
    # 时间步进循环
    for n in range(1, nt):
        # 使用拉普拉斯算子计算二阶空间导数
        du_dt = r * laplace(u)
        # 更新温度分布
        u += du_dt
        # 应用边界条件
        u[0] = 0.0
        u[-1] = 0.0
        
        t = n * dt  # 更新当前时间
        
        # 在指定时间点保存结果
        for plot_time in plot_times:
            if abs(t - plot_time) < dt/2 and plot_time not in results['times']:
                results['times'].append(t)
                results['solutions'].append(u.copy())
    
    results['computation_time'] = time.time() - start_time  # 计算 elapsed 时间
    results['stability_parameter'] = r  # 存储稳定性参数
    results['x'] = x  # 添加空间坐标
    
    return results
```

### 3.2 隐式差分法

**核心思想：** [简述算法思路]

**优势：** 无条件稳定

**关键代码片段：**
```python
# 隐式有限差分法（BTCS）
# ---------------------
def solve_implicit(L, alpha, nx, T_final, dt, plot_times=None):
    """
    使用隐式有限差分法（BTCS）求解热传导方程。
    
    参数：
        L (float)：求解域的长度
        alpha (float)：热扩散系数
        nx (int)：空间网格点数量
        T_final (float)：最终模拟时间
        dt (float)：时间步长
        plot_times (list)：需要保存结果的时间点列表
        
    返回：
        dict：包含求解结果的字典，包括时间点、温度分布、计算时间等
    """
    if plot_times is None:
        plot_times = [0, 1, 5, 15, 25]
    
    # 计算空间步长
    dx = L / (nx - 1)
    # 计算稳定性参数
    r = alpha * dt / (dx**2)
    # 计算总时间步数
    nt = int(T_final / dt) + 1
    
    # 获取初始条件
    u, x = set_initial_condition(L, nx)
    # 内部节点数量（不包括边界）
    num_internal = nx - 2
    
    # 为隐式方法构造三对角矩阵
    banded_matrix = np.zeros((3, num_internal))
    banded_matrix[0, 1:] = -r      # 上对角线
    banded_matrix[1, :] = 1 + 2*r  # 主对角线
    banded_matrix[2, :-1] = -r     # 下对角线
    
    # 存储结果的字典
    results = {'times': [], 'solutions': [], 'method': '隐式有限差分法（BTCS）'}
    
    # 存储初始条件
    if 0 in plot_times:
        results['times'].append(0.0)
        results['solutions'].append(u.copy())
    
    start_time = time.time()  # 开始计时
    
    # 时间步进循环
    for n in range(1, nt):
        # 构造右侧向量（当前内部节点的值）
        rhs = u[1:-1].copy()
        # 求解三对角线性系统
        u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix, rhs)
        # 更新内部节点的温度值
        u[1:-1] = u_internal_new
        # 应用边界条件
        u[0] = 0.0
        u[-1] = 0.0
        
        t = n * dt  # 更新当前时间
        
        # 在指定时间点保存结果
        for plot_time in plot_times:
            if abs(t - plot_time) < dt/2 and plot_time not in results['times']:
                results['times'].append(t)
                results['solutions'].append(u.copy())
    
    results['computation_time'] = time.time() - start_time  # 计算 elapsed 时间
    results['stability_parameter'] = r  # 存储稳定性参数
    results['x'] = x  # 添加空间坐标
    
    return results
```

### 3.3 Crank-Nicolson方法

**核心思想：** [简述算法思路]

**精度：** 时间和空间都是二阶精度

**关键代码片段：**
```python
# ---------------------
# 克兰克-尼科尔森方法
# ---------------------
def solve_crank_nicolson(L, alpha, nx, T_final, dt, plot_times=None):
    """
    使用克兰克-尼科尔森方法求解热传导方程。
    
    参数：
        L (float)：求解域的长度
        alpha (float)：热扩散系数
        nx (int)：空间网格点数量
        T_final (float)：最终模拟时间
        dt (float)：时间步长
        plot_times (list)：需要保存结果的时间点列表
        
    返回：
        dict：包含求解结果的字典，包括时间点、温度分布、计算时间等
    """
    if plot_times is None:
        plot_times = [0, 1, 5, 15, 25]
    
    # 计算空间步长
    dx = L / (nx - 1)
    # 计算稳定性参数
    r = alpha * dt / (dx**2)
    # 计算总时间步数
    nt = int(T_final / dt) + 1
    
    # 获取初始条件
    u, x = set_initial_condition(L, nx)
    # 内部节点数量
    num_internal = nx - 2
    
    # 为克兰克-尼科尔森方法构造三对角矩阵
    banded_matrix_A = np.zeros((3, num_internal))
    banded_matrix_A[0, 1:] = -r/2    # 上对角线
    banded_matrix_A[1, :] = 1 + r    # 主对角线
    banded_matrix_A[2, :-1] = -r/2   # 下对角线
    
    # 存储结果的字典
    results = {'times': [], 'solutions': [], 'method': '克兰克-尼科尔森方法'}
    
    # 存储初始条件
    if 0 in plot_times:
        results['times'].append(0.0)
        results['solutions'].append(u.copy())
    
    start_time = time.time()  # 开始计时
    
    # 时间步进循环
    for n in range(1, nt):
        # 构造右侧向量（当前和未来时间的混合项）
        u_internal = u[1:-1]
        rhs = (r/2) * u[:-2] + (1 - r) * u_internal + (r/2) * u[2:]
        # 求解三对角线性系统
        u_internal_new = scipy.linalg.solve_banded((1, 1), banded_matrix_A, rhs)
        # 更新内部节点的温度值
        u[1:-1] = u_internal_new
        # 应用边界条件
        u[0] = 0.0
        u[-1] = 0.0
        
        t = n * dt  # 更新当前时间
        
        # 在指定时间点保存结果
        for plot_time in plot_times:
            if abs(t - plot_time) < dt/2 and plot_time not in results['times']:
                results['times'].append(t)
                results['solutions'].append(u.copy())
    
    results['computation_time'] = time.time() - start_time  # 计算 elapsed 时间
    results['stability_parameter'] = r  # 存储稳定性参数
    results['x'] = x  # 添加空间坐标
    
    return results

```

### 3.4 solve_ivp方法

**核心思想：** [简述算法思路]

**优势：** 自适应步长，高精度

**关键代码片段：**
```python
# solve_ivp 方法
# ---------------------
def heat_equation_ode(t, u_internal, L, alpha, nx):
    """
    为 solve_ivp 定义常微分方程组。
    
    参数：
        t (float)：当前时间
        u_internal (np.ndarray)：内部节点的温度
        L (float)：求解域的长度
        alpha (float)：热扩散系数
        nx (int)：空间网格点数量
        
    返回：
        np.ndarray：内部节点温度的时间导数
    """
    # 重建完整的温度分布（包括边界条件）
    dx = L / (nx - 1)
    u_full = np.concatenate(([0.0], u_internal, [0.0]))
    # 使用拉普拉斯算子计算二阶空间导数
    d2u_dx2 = laplace(u_full) / (dx**2)
    # 返回内部节点的时间导数
    return alpha * d2u_dx2[1:-1]

def solve_with_solve_ivp(L, alpha, nx, T_final, method='BDF', plot_times=None):
    """
    使用 scipy.integrate.solve_ivp 求解热传导方程。
    
    参数：
        L (float)：求解域的长度
        alpha (float)：热扩散系数
        nx (int)：空间网格点数量
        T_final (float)：最终模拟时间
        method (str)：积分方法
        plot_times (list)：需要保存结果的时间点列表
        
    返回：
        dict：包含求解结果的字典，包括时间点、温度分布、计算时间等
    """
    if plot_times is None:
        plot_times = [0, 1, 5, 15, 25]
    
    # 获取初始条件
    u0, x = set_initial_condition(L, nx)
    # 内部节点的初始温度（不包括边界）
    u0_internal = u0[1:-1]
    
    start_time = time.time()  # 开始计时
    
    # 求解常微分方程组
    sol = solve_ivp(
        fun=lambda t, u: heat_equation_ode(t, u, L, alpha, nx),
        t_span=(0, T_final),
        y0=u0_internal,
        method=method,
        t_eval=plot_times,
        rtol=1e-8,
        atol=1e-10
    )
    
    computation_time = time.time() - start_time  # 计算 elapsed 时间
    
    # 重建完整解（包括边界条件）
    results = {
        'times': sol.t.tolist(),
        'solutions': [],
        'method': f'solve_ivp ({method})',
        'computation_time': computation_time,
        'x': x  # 添加空间坐标
    }
    
    for i in range(len(sol.t)):
        u_full = np.concatenate(([0.0], sol.y[:, i], [0.0]))
        results['solutions'].append(u_full)
    
    return results

```

## 4. 实验结果

### 4.1  数值结果

#### 4.1.1 温度分布演化

![image](https://github.com/user-attachments/assets/a0443274-f70c-437a-9db5-733931172747)


#### 4.1.2 计算效率比较

| 方法 | 计算时间 (秒) | 时间步数 | 效率评价 |
|------|---------------|----------|----------|
| 显式差分法 | [0.0193] | [填入] | [评价] |
| 隐式差分法 | [0.0020] | [填入] | [评价] |
| Crank-Nicolson | [0.0010] | [填入] | [评价] |
| solve_ivp | [0.0429] | [填入] | [评价] |

#### 4.2.3 精度分析

以solve_ivp方法作为参考解，计算其他方法的相对误差：

| 方法 | 最大相对误差 | 平均相对误差 | 精度评价 |
|------|--------------|--------------|----------|
| 显式差分法 | [填入] | [填入] | [评价] |
| 隐式差分法 | [填入] | [填入] | [评价] |
| Crank-Nicolson | [填入] | [填入] | [评价] |

### 4.3 稳定性验证

#### 4.3.1 显式方法稳定性

- 稳定性参数： $r =$ [计算值]
- 稳定性判断：[稳定/不稳定]
- 观察现象：[描述数值解的行为]

#### 4.3.2 隐式方法稳定性

- 大时间步长测试： $\Delta t =$ [测试值]
- 稳定性表现：[描述观察结果]

## 5. 结果分析与讨论

### 5.1 方法比较

#### 5.1.1 精度比较

[分析各方法的精度特点，解释精度差异的原因]

#### 5.1.2 效率比较

[分析各方法的计算效率，讨论时间步长限制的影响]

#### 5.1.3 稳定性比较

[比较各方法的稳定性特点，解释稳定性条件的物理意义]

### 5.2 物理现象分析

#### 5.2.1 热扩散过程

[描述温度分布的演化规律，解释物理现象]

#### 5.2.2 边界条件影响

[分析零边界条件对热扩散过程的影响]

### 5.3 数值方法选择建议

根据实验结果，针对不同应用场景提出方法选择建议：

1. **高精度要求**：[推荐方法及理由]
2. **快速计算**：[推荐方法及理由]
3. **长时间模拟**：[推荐方法及理由]
4. **实时应用**：[推荐方法及理由]

## 6. 问题与收获

### 6.1 遇到的主要问题

1. **[问题1]**：[描述问题]
   - 解决方法：[描述解决过程]
   - 经验总结：[总结经验]

2. **[问题2]**：[描述问题]
   - 解决方法：[描述解决过程]
   - 经验总结：[总结经验]

### 6.2 主要收获

1. **理论理解**：[描述对数值方法理论的理解]
2. **编程技能**：[描述编程能力的提升]
3. **科学计算思维**：[描述科学计算思维的培养]
4. **问题解决能力**：[描述问题解决能力的提升]

## 7. 思考题

### 7.1 稳定性分析

为什么显式差分法需要满足稳定性条件 $r \leq 0.5$，而隐式方法无条件稳定？请从数学角度分析。

**答案：** [你的分析]

### 7.2 精度提升

如何进一步提高数值解的精度？请提出至少两种方法并说明原理。

**答案：** [你的建议]

### 7.3 实际应用

在实际工程问题中，如何根据具体需求选择合适的数值方法？

**答案：** [你的思考]

### 7.4 扩展问题

如果要求解二维或三维热传导方程，各种方法的优缺点会如何变化？

**答案：** [你的分析]

## 8. 完整代码

[如果需要，可以在此处附上完整的实现代码]


